<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SQLite学习笔记]]></title>
    <url>%2F2019%2F02%2F27%2FSQLite%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[SQLite简介SQLite是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的SQL数据库引擎。它是一个零配置的数据库，这意味着与其他数据库一样，您不需要在系统中配置。就像其他数据库，SQLite引擎不是一个独立的进程，可以按应用程序需求进行静态或动态连接。SQLite直接访问其存储文件。 SQLite安装在windows上安装SQLite 请访问SQLite下载页面，从winsdows区下载预编译的二进制文件。 您需要下载sqlite-tools-win32-.zip和sqlite-dll-win32-.zip压缩文件 创建文件夹 C:\sqlite，并在此文件夹下解压上面两个压缩文件，将得到 sqlite3.def、sqlite3.dll 和 sqlite3.exe 文件。 添加 C:\sqlite 到 PATH 环境变量，最后在命令提示符下，使用 sqlite3 命令，将显示如下结果。 12345C:\&gt;sqlite3SQLite version 3.7.15.2 2013-01-09 11:53:05Enter &quot;.help&quot; for instructionsEnter SQL statements terminated with a &quot;;&quot;sqlite&gt; 在Linux上安装SQLite查看本机是否已经安装了SQLite12345$ sqlite3SQLite version 3.7.15.2 2013-01-09 11:53:05Enter &quot;.help&quot; for instructionsEnter SQL statements terminated with a &quot;;&quot;sqlite&gt; 如果没有，可以使用apt-get安装 在Mac OS X 上安装SQLite最新版本的Mac OS X 会预安装SQLite,但是如果没有可用的安装，只需按照如下步骤进行：请访问SQLite下载页面,从源代码区下载sqlite-autoconf-*.tar.gz。步骤如下12345$ tar xvzf sqlite-autoconf-3071502.tar.gz$ cd sqlite-autoconf-3071502$ ./configure --prefix=/usr/local$ make$ make install 上述步骤将在 Mac OS X 机器上安装 SQLite，您可以使用下列命令进行验证：12345$ sqlite3SQLite version 3.7.15.2 2013-01-09 11:53:05Enter &quot;.help&quot; for instructionsEnter SQL statements terminated with a &quot;;&quot;sqlite&gt; SQLite命令在命令提示符下键入一个简单的 sqlite3 命令，在 SQLite 命令提示符下，您可以使用各种 SQLite 命令。1234$ sqlite3SQLite version 3.3.6Enter &quot;.help&quot; for instructionssqlite&gt; 如需获取可用的点命令的清单，可以在任何时候输入 “.help”。例如：1sqlite&gt;.help 上面的命令会显示各种重要的 SQLite 点命令的列表，如下所示： —|:–:|.backup?DB?FILE|备份DB数据库（默认是“main”）到FILE文件.bail ON|OFF|发生错误后停止。默认为OFF。.databases|列出数据库的名称及其所依附的文件.dump?TABLE?|以SQL文本格式转储数据库。如果指定了TABLE表，则只转储匹配LIKE模式的TABLE表.echo ON&amp;#124OFF|开启或关闭日志。FILE文件可以是stderr(标准错误)/stdout(标准输出).mode MODE|设置输出模式，MODE可以是下列之一：.nullvalues STRING|在NULL值的地方输出STRING字符串.output FILENAME|发送输出到FILENAME文件.output stdout|发送输出到屏幕.print STRING…逐字地输出STRING字符串.prompt MAIN CONTINUM|替换标准提示符.quit|退出SQLite提示符.read FILENAME|执行FILENAME文件中的SQL.schema?TABLE?|显示CREATE语句。如果指定了TABLE表，则只显示匹配LIKE模式的TABLE表 SQLite语法 SQLite 是不区分大小写的，但也有一些命令是大小写敏感的，比如GLOB和glob在SQLite的语句中有不同的含义 SQLite 注释以两个连续的 “-“ 字符（ASCII 0x2d）开始，并扩展至下一个换行符（ASCII 0x0a）或直到输入结束，以先到者为准。 所有的 SQLite 语句可以以任何关键字开始，如 SELECT、INSERT、UPDATE、DELETE、ALTER、DROP 等，所有的语句以分号（;）结束。 SQLite数据类型SQLite 数据类型是一个用来指定任何对象的数据类型的属性。SQLite 中的每一列，每个变量和表达式都有相关的数据类型。您可以在创建表的同时使用这些数据类型。SQLite 使用一个更普遍的动态类型系统。在 SQLite 中，值的数据类型与值本身是相关的，而不是与它的容器相关。 SQLite 创建数据库1$sqlite3 DatabaseName.db SQLite 附加数据库假设这样一种情况，当在同一时间有多个数据库可用，您想使用其中的任何一个。SQLite 的 ATTACH DATABASE 语句是用来选择一个特定的数据库，使用该命令后，所有的 SQLite 语句将在附加的数据库下执行。1ATTACH DATABASE &apos;DatabaseName&apos; As &apos;Alias-Name&apos;; 分离数据库1DETACH DATABASE &apos;Alias-Name&apos;; SQLite创建表1234567CREATE TABLE database_name.table_name( column1 datatype PRIMARY KEY(one or more columns), column2 datatype, column3 datatype, ..... columnN datatype,); SQLite 删除表1DROP TABLE database_name.table_name; SQLite Insert语句12INSERT INTO TABLE_NAME [(column1, column2, column3,...columnN)] VALUES (value1, value2, value3,...valueN); SQLite select语句1SELECT column1, column2, columnN FROM table_name; SQLite运算符运算符是一个保留字或字符，主要用于 SQLite 语句的 WHERE 子句中执行操作，如比较和算术运算。运算符用于指定 SQLite 语句中的条件，并在语句中连接多个条件。 算术运算符 比较运算符 逻辑运算符 位运算符 SQLite 表达式布尔表达式123SELECT column1, column2, columnN FROM table_name WHERE SINGLE VALUE MATCHING EXPRESSION; 数值表达式12SELECT numerical_expression as OPERATION_NAME[FROM table_name WHERE CONDITION] ; 日期表达式12sqlite&gt; SELECT CURRENT_TIMESTAMP;CURRENT_TIMESTAMP = 2013-03-17 10:43:35 SQLite WHERE子句123SELECT column1, column2, columnN FROM table_nameWHERE [condition] SQLite AND/OR 运算符AND 运算符123SELECT column1, column2, columnN FROM table_nameWHERE [condition1] AND [condition2]...AND [conditionN]; OR 运算符123SELECT column1, column2, columnN FROM table_nameWHERE [condition1] OR [condition2]...OR [conditionN] SQLite Update 语句123UPDATE table_nameSET column1 = value1, column2 = value2...., columnN = valueNWHERE [condition]; SQLite Delete 语句12DELETE FROM table_nameWHERE [condition]; SQLite Like 子句SQLite 的 LIKE 运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，LIKE 运算符将返回真（true），也就是 1。这里有两个通配符与 LIKE 运算符一起使用： 百分号（%） 下划线（—）分号（%）代表零个、一个或多个数字或字符。下划线（_）代表一个单一的数字或字符。这些符号可以被组合使用。 SQLite GLob 子句SQLite 的 GLOB 运算符是用来匹配通配符指定模式的文本值。如果搜索表达式与模式表达式匹配，GLOB 运算符将返回真（true），也就是 1。与 LIKE 运算符不同的是，GLOB 是大小写敏感的，对于下面的通配符，它遵循 UNIX 的语法。 星号 （*） 问号 （?）星号（*）代表零个、一个或多个数字或字符。问号（?）代表一个单一的数字或字符。这些符号可以被组合使用。 SQLite limit子句123SELECT column1, column2, columnN FROM table_nameLIMIT [no of rows] OFFSET [row num] SQLite Order By1234SELECT column-list FROM table_name [WHERE condition] [ORDER BY column1, column2, .. columnN] [ASC | DESC]; SQLite Group By12345SELECT column-listFROM table_nameWHERE [ conditions ]GROUP BY column1, column2....columnNORDER BY column1, column2....columnN Having 子句HAVING 子句允许指定条件来过滤将出现在最终结果中的分组结果。WHERE 子句在所选列上设置条件，而 HAVING 子句则在由 GROUP BY 子句创建的分组上设置条件。 SQLite Distinct 关键字SQLite 的 DISTINCT 关键字与 SELECT 语句一起使用，来消除所有重复的记录，并只获取唯一一次记录。有可能出现一种情况，在一个表中有多个重复的记录。当提取这样的记录时，DISTINCT 关键字就显得特别有意义，它只获取唯一一次记录，而不是获取重复记录。123SELECT DISTINCT column1, column2,.....columnN FROM table_nameWHERE [condition]]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象相关语法及其语义]]></title>
    <url>%2F2018%2F12%2F13%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%AD%E6%B3%95%E7%9B%B8%E5%85%B3%E8%AF%AD%E6%B3%95%E5%8F%8A%E5%85%B6%E8%AF%AD%E4%B9%89%2F</url>
    <content type="text"><![CDATA[Java 面向对象概念对象的基本概念所谓对象就是真实世界中的实体，对象与实体是一一对应的，也就是说现实世界中每一个实体都是一个对象，它是一种具体的概念。对象有以下特点: 对象是类的一个实例; 语义是表达Java类的一个实体; 对象是一般情况下Java语言里的”一等公民”; 对象可以赋值到一个变量; 对象通过new语句进行创建; 面向对象的三大特性封装（Encapsulation）在面向对象的程序设计中，封装是指一种将类实现细节部分包装，隐藏起来的方法。 封装的方式：类类是一个模板，它描述一类对象的行为和状态。语义上表达的是一类实体（对象）的抽象。 对类的内部状态的访问进行控制，只提供该提供的信息。 把代码分成两部分: 接口和实现。 接口因为涉及和外部的交互，对用户暴露，应该保持稳定，例如API库 内部实现不需要暴露给外部用户。在接口功能不被影响的前提下，可以随意修改和重构 良好的封装是解耦的基础 1234567891011121314151617181920public class article &#123; private String title; private String content; public String getTitle() &#123; return title; &#125; public String getContent() &#123; return content; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public void setContent(String content) &#123; this.content = content; &#125;&#125; 例如，创建一个article类，用private修饰符将title，content属性私有化，通过getter/setter方法读写属性，这样不仅可以控制title,content属性的可访问性，还可以在getter/setter方法中加入属性控制语句，比如，在setter方法中可以控制title,content的字数。 继承 继承是Java面向对象编程技术的一块基石，因为它允许创建分等级层次的类封装方式: 类。 子类继承父类的特征和行为，使得子类对象具有父类对象的特征和方法。 继承需要符合一个关系: is-a 子类是更具体的父类 在声明子类时候，通过关键字”extends”继承 继承的特性: 子类拥有父类非private的成员变量和方法。 子类可以拥有自己的成员变量和方法，即子类可以对父类进行扩展。 子类可以重新实现父类的方法。override Java只支持单继承，即只能有一个父类 super关键字: 我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类 this关键字: 指向自己的引用。 12345678910111213141516171819202122232425262728293031323334353637383940public class Animal &#123; protected String name; protected String age; public Animal()&#123;&#125; public Animal(String name,String age) &#123; name = name; age = age; &#125; public void walk() &#123; System.out.println("会走路"); &#125;&#125;public class Dog extends Animal&#123; public Dog()&#123; super(); &#125; public Dog(String name, String dog)&#123; super(name, dog); &#125; public void say() &#123; System.out.println("汪汪"); &#125;&#125;public class Cat extends Animal &#123; public Cat() &#123; super(); &#125; public Cat(String name, String age) &#123; super(name, age); &#125; public void say() &#123; System.out.println("喵喵"); &#125; @override public void walk() &#123; System.out.println("会爬树") &#125;&#125; dog和cat都是animal的子类，通过extends关键字继承父类的属性和方法。 多态抽象类 目的就是用于继承之后定义子类的类，必然会用于定义子类 抽象类除了不能实例化对象之外，类的其他功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样 由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用 使用修饰符abstract 声明一个类似抽象类，一般具有抽象方法：abstract void method();抽象方法只有声明，没有实现 子类继承抽象类之后，必须实现抽象方法，不然仍然为抽象类，可以override其他方法 static方法不能声明为抽象方法 is-a 关系！ 接口 接口是一系列抽象方法（但不需要abstract修饰，隐式是public abstract）的集合 语义上表示具有一定的特性，比如行走：但是没有如何行走的定义显示：表示可以显示，但是没有如何显示的定义 接口成员变量只能是static final的。因为它不是类，不能实例化对象，所以不会有状态，只有属性 类通过关键字implements表达实现一个接口，从而声明这个类具有接口定义的属性和行为 类可以实现多个接口！例如表示：一个文件即可以显示也可以打印。 多态 多态表示一个类型（父类或者接口）的变量的方法的具体实现行为由变量指向的具体对象确定 主要的实现方式： 继承和接口 父类和接口类型的变量赋值子类对象 调用被override的方法 我们在NewsReader.java文件中定义了一个抽象类NewsReader来读取新闻，但读取的方式可能不同，需要具体的类实现，FileNewsReader.java和UrlNewsReader.java文件中定义的FileNewsReader和UrlNewsReader类继承NewsReader类并具体实现了readNews方法。NewsReader.java123456789public abstract class NewsReader &#123; public abstract News readNews(); //具有这个功能，但是具体的功能实现在子类中确定 //文件、类 // 纯文本，word,json,xml --&gt; 类 // 标准输入 --&gt; 类 // 语音识别 --&gt; 类 // 不同的reader&#125; FileNewsReader.java123456public class FileNewsReader extends NewsReader&#123; @Override public News readNews() &#123; return new News("abc", "test"); &#125;&#125; UrlNewsReader.java123456public class UrlNewsReader extends NewsReader&#123; @Override public News readNews() &#123; return new News("efg", "testurl"); &#125;&#125; 抽象类和接口在语义上是不同的，实际开发中要根据语义选择适合的方式。比如狗和猫都是动物，具有一些共同的行为，可以将它们抽象成Animal类。而接口更多地表达一种行为，例如，video和Lecture都有需要展示的部分，但具体展示什么，如何展示就需要具体的类实现。在Displayable.java中定义一个接口Displayable123public interface Displayable &#123; void display();&#125; 在Video.java和Lecture.java中实现Displayable这个接口。Video.java123456public class Video implements Displayable&#123; @Override public void display() &#123; System.out.println("正在播放视频"); &#125;&#125; Lecture.java123456public class Lecture implements Displayable&#123; @Override public void display() &#123; System.out.println("正在上课中，播放讲义"); &#125;&#125; 多态本身是一种抽象化的体现，把一系列具体事物的共同特点抽象出来，再通过这个抽象的事物，与不同的具体事物进行对话。简单而言，就是“一个接口，多种实现”。Video和Lecture都是接口Displayable的具体实现。所以主方法中的viewNews方法接收的参数可以是Displayable,而调用时参数可以是Displayable的多种形态。从而避免了分别定义Lecture和Video的显示（ViewLecture和Viewvideo）。 Main.java123456789101112131415161718192021public class Main &#123; public static void main(String[] args) throws IOException &#123; Video video = new Video(); Lecture lecture = new Lecture(); viewNews(video); viewNews(lecture); &#125; private static void viewNews(Displayable item) &#123; item.display(); System.out.println("播放完毕"); &#125;// private static void viewLeture(Lecture lecture) &#123;// lecture.display();// &#125;//// private static viewvideo(Video video) &#123;// video.display();// &#125;&#125;]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基本语法简介]]></title>
    <url>%2F2018%2F12%2F09%2FJava%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[数据类型基本类型八种基本类型1.六种数字类型（四种整数型，两个浮点型）：整数型 byte (1 byte) : -128 ~ +127 short (2 byte) -32768 ~ 32767 int （4 byte） -2147438648 ~ +2147438647 long (8 byte) unsigned byte (1 byte): 0 ~ 255 unsigned short (2 bytes): 0 ~ 0~65535 unsigned int (4 bytes): 0~4294967295 unsigned long (8 bytes) 浮点数 float (4 byte): 3.4E-38 - 3.4E+38精度：8, 23 double (8 byte): 1.7E-308 —— 1.7E+308精度：11, 52 2.一种字符类型：char 3.一种布尔类型：boolean 有且只有这八种基本类型，每种基本类型都有对应的包装类 123int num 5double square = 13.4boolean isUpdated = true 引用类型对象、数组和枚举都是引用类型Class,Interface,Array,Enum12Apple a = new Apple();List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); 表达式和语句表达式就是计算过程 基本的数学计算“1+2”, “3/5”,”3&gt;5”,”1==2”每个表达式都有一个返回值 方法调用“sqrt(1)”,”dog.walk()”方法调用可以有返回值方法调用也可以没有返回值（或者说是返回值为空） 表达式和语句都已”;”表示结束 变量和赋值 变量是对一个Java对象的引用 声明一个变量时候需要指定其类型，表示它可以引用的对象类型 赋值是把一个对象绑定到一个变量，反过来说，是让一个变量引用到一个对象 语法：&lt;类型&gt; 变量名 = 值 eg:1234int count = 3;String fruitName = "apple";double pi = 3.1414526;char ch = "x"; 控制语句逻辑控制语句 if语句 123if(布尔表达式) &#123; //执行语句&#125; if-else 语句 12345if(布尔表达式) &#123; // 如果布尔表达式的值为true&#125; else &#123; // 如果布尔表达式的值为false&#125; if - else if - else 语句 1234567if (布尔表达式1) &#123; //布尔表达式1为真时执行的语句&#125; else if(布尔表达式2)&#123; // 布尔表达式2为真时执行的语句&#125; else &#123; //以上都不为真时执行的语句&#125; 嵌套if语句 123456if(布尔表达式1) &#123; // 布尔表达式1为真时执行的语句 if(布尔表达式2) &#123; 布尔表达式2为真时执行的语句 &#125;&#125; switch 语句 12345678910switch(expression) &#123; case value: //语句 break; case value: //语句 break; default: //语句&#125; 循环控制语句如果想要同样的操作执行多次，就需要使用循环结构Java中有三种主要的循环结构： while 循环 123while(布尔表达式) &#123; //循环内容&#125; do…while 123do &#123; //代码语句&#125; while(布尔表达式); for (循环) 123for(初始值; 布尔表达式; 更新) &#123; //代码语句&#125; Java类型模型 类：类是一个模板，它描述一类对象的行为和状态 对象: 对象是类的一个实例， 有具体的状态 方法：类中定义的该类的实例对象所具有的行为 静态方法： 隶属于类本身的方法 Java里的常量和变量都可以对应于一个对象， 这个对象的行为和具有的属性是由类来定义的 Java 程序的基本结构就是一系列类的定义，类之间的关系和具体类的对象之间的互相操作 Java类 类是一个模板，他描述一类对象的行为和状态 语义上表达的是一类实体（对象）的抽象 在Java 中的惯例是一个文件中存放一个public类 Java对象 对象：对象是类的一个实例 语义上是表达一个java类的实体 对象是一般情况下Java语言里的”一等公民” 对象可以赋值到一个变量 对象是通过new语句进行创建 Java方法和成员变量 方法：类中定义的该类的实例对象所具有的行为 静态方法： 隶属于类本身的方法 &lt;返回类型&gt; 方法名（&lt;参数类型&gt; 参数名） {代码;return&lt;返回值&gt;;} 一个方法由”方法名 + 参数类型”确定 相同方法名，不同参数类型，是不同的方法（重载） 成员变量即对象或类中的变量，其作用域在类中，或对象中 可以用修饰符控制方法和成员变量的作用域 修饰符 修饰符用于控制变量，类的作用域和一些访问限制 访问修饰符 访问权限修饰符： public,protected,private,default(即不设置) private和protected 不能修饰外部类 修饰符 当前类 同一包内 子孙类（同一包） 子孙类（不同包） 其他包 public Y Y Y Y Y protected Y Y Y 子孙与基类是否在同一包中 N default Y Y Y N N private Y N N N N 非访问修饰符static 修饰符：用来修饰类方法和类变量final 修饰符：用来修饰类、方法和变量，final修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。abstract 修饰符：用来创建抽象类和抽象方法synchronized和volatile修饰符：主要用于多线程并发编程。 包和层次结构 “包”： 用来表示具有层次结构的命名空间 “package com.jirengu.java-system;” 层次结构：包 –&gt; 类（对象）–&gt; 方法 –&gt; 代码块]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
